#+title: FrostAV Final Report
** Requirements Evaluation
*** Problem Domain Requirements
The main problem-domain requirements for this project are:
   1. Given a _lane_, the car must travel approximately parallel to it,
      such that the car stays within its _boundaries_ consistently,
      and, if the car is to accidentally leave it, it promptly
      returns.
   2. Given a _corner_, the car must turn, continuing from the car’s
      current _lane_ to the next, such that the car stays within its
      _boundaries_ consistently, and, if the car is to accidentally
      leave it, it promptly returns.
   3. Given an _obstacle_, the car must stop until it is moved
      further from the car, or it is removed from _circuit boundaries_.
   4. Given a _sign_, the car must respond to the event provided by it.
   5. Given a _circuit_, the car must complete a full loop.

   #+caption: An example _circuit_ which the car must navigate through.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/environment.png]]

The completed project is fully capable of meeting requirements 1, 2 and 5 and is unable to meet 3 and 4. The car can successfully navigate a straight path and recover from small excursions outside of the lane boundaries. It can also navigate corners and complete a circuit. Obstacle detection and sign detection was never implemented due to a lack of time.

*** Control System and Control Module Requirements
For the control system and control modules, the following requirements apply:
    The Control System shall:
   1. Interface with vehicle peripherals, such as, motors, servos,
      batteries, etc.
   2. Be the only system coupled to the vehicle. 
   3. Have a subset of Control Modules for each peripheral in need
      of control.

    Each Control Module shall:
   1. Encapsulate a single purpose, such that, one controller controls
      a single peripheral.
   2. Couple to a peripheral electronically, not mechanically.
   3. Be able to communicate with other controllers via a wired bus.
   4. Be able to communicate with non-controllers that depend on it,
      via a wired bus.
   5. Communicate with other controllers and non-controllers via a
      single shared wired bus.

All the control system and control module requirements were met, except for the requirement that each control module must control a single peripheral. In the final design, the ATMEGA328 is used for both servo and throttle control instead of having a separate module for each. Otherwise, the control system was able to successfully interface with the vehicle peripherals using control modules, and the control modules share a single I2C bus. All control modules can communicate with the Raspberry Pi, which runs the main control system, and with each other (even though this capability was not utilized for the final design).

*** Autonomy Requirements

The vehicle’s autonomy system shall:
   1. Not be directly coupled to the Vehicle Interface (section [[#vehicle-interface-requirements]]).
   2. Be able to fit on the vehicle.
   3. Allow the vehicle to navigate, as per section
      [[#problem-domain-requirements]], without user interaction.
   4. Be able to communicate with the Control System (section [[#Control System and Control Module Requirements]]).
The final design is capable of meeting all the autonomy requirements. The autonomy system can communicate with all modules that make up the control system, including communicating with multiple modules in quick succession. The system is not directly coupled to the vehicle interface, instead performing all vehicle functions using control modules. The system fits on the vehicle and allows the vehicle to navigate autonomously.

*** Vehicle Interface Requirements

The vehicle interface shall:
    1. Include a way for the vehicle to be turned on and off, such
       that, the vehicle receives no power to the _drive system_ or
       _logic_ when off.
    2. Include a way for the vehicle to have its _logic_ turned on,
       while the _drive system_ is off.
    3. Provide a battery peripheral that powers the _logic_.
    4. Provide a battery peripheral that powers the _drive system_.
    5. The total power consumption of the _logic_ and _drive system_
       cannot exceed the maximum capacity of the battery
       peripheral(s).
    6. Provide a peripheral that moves the vehicle.
    7. Provide a peripheral that steers the vehicle.
    8. Provide an electronic interface from each peripheral.

All vehicle interface requirements were met with the final design. The design meets requirements 1 and 2 with a power switch on the logic battery, and a power switch and remote cutoff on the drive battery. This allows the logic to be powered independently of the drive system. Requirements 3 and 4 are met with the inclusion of the logic and drive batteries as well as the logic power supply. The batteries and power supply allow all the logic and drive system modules to be powered. 

Requirement 5 is met by ensuring that the maximum power draw won’t exceed the batteries maximum rating. All of the batteries used in this design are rated at 30C or greater, which is a measure of a batteries maximum discharge rate. For the 5200 mAh drive battery, a 30C rating corresponds to a maximum output of 156 A. The ESC used to power the drive motor and servo is rated for a maximum of 60A, so the maximum potential current draw is well within the battery’s capabilities. The logic battery, which has a capacity of 2200 mAh and a discharge rating of 30C can supply a maximum of 66A. Since all logic is powered by the power supply (which has a current limiting function) the maximum current drawn from this battery will never exceed 3A. 

Requirements 6 and 7 are met by the ATMEGA328, the motor, ESC and steering servo. The ATMEGA328 controls the servo and ESC, and the ESC regulates the motor’s speed. These components allow the vehicle to be steered and moved by the autonomy system. Each peripheral also has an electronic interface. The ATMEGA328 communicates with the autonomy system, which is running on a Raspberry Pi using the I2C bus. The voltage and current draw of the logic battery are measured using the INA226 power monitoring chip built into the power supply and communicated to the autonomy system over the I2C bus.

*** Wireless Interface Requirements
    The Wireless Interface shall:
    1. Allow for wireless tunneling (e.g. via SSH)
    2. Be able to access a server.
    3. Provide bi-directional communication.

All of these requirements for the wireless system are met in the final design, using the Raspberry Pi 4’s integrated WiFi. The Wifi connection allows for SSH tunneling as well as providing a HTTP server. The system is also capable of connecting to a server using SSH tunneling. The Wifi is also fully capable of bi-directional communication.

** Additional Capabilities

During the development of the vehicle, a few additional capabilities and features were able to be implemented.

*** Status OLED Display

   #+caption: OLED display showing parameters.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/oled.jpg]]

A SSD1306 OLED display module was added to the design towards the end of Milestone 4, which allows easier monitoring of the Raspberry Pi and battery parameters. The display shows the current IP address of the Pi, the CPU load and temperature, memory usage, and the voltage, current draw and power use from the logic battery. 

This display has been useful in the development of the system because it allows important parameters to be monitored easily. Since the Clarkson University Wifi uses DHCP addresses, the Pi’s IP changes periodically. The IP is needed for accessing SSH and the Pi’s webserver so this is a very useful parameter to have. The voltage monitoring serves as a low battery indication for the logic battery.

*** HTTP Status Monitoring

   #+caption: An example _circuit_ which the car must navigate through.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/web_screenshot.png]]

Similar to the OLED display, a web server was implemented on the Pi to monitor various parameters. The parameters monitored are the Pi’s CPU load, memory use, CPU and GPU temperature, and power, voltage and current from the logic battery. These parameters are graphed using JavaScript and the values are retrieved with PHP. The graphs update every 10 seconds and display the last 20 values. The webpage is accessed at the Pi’s IP address.

This feature allows various parameters to be measured and allows the easy identification of trends in these values. The function of this webpage is like the OLED display, in that it’s useful for the development of the system. This allowed for the identification of thermal throttling on the PI during testing.

*** Remote Motor/Servo Shutoff

   #+caption: Shutoff remote control.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/failsafe_remote_1.JPG]]

A remote shutoff system was implemented using Xbee radio modules and an IRF250 power MOSFET. The MOSFET cuts power to the motor speed controller and servo when the switch on the remote control unit is flipped. This system allows the car to be stopped remotely if it were to go out of control. The system is designed so that any failure will disconnect power to the motor and servo. If the Xbee on the car side loses signal or power, it will stop the motor.

** Unique Innovations
*** Custom Power Supply

   #+caption: Power Supply complete.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/powersupply.jpg]]

A custom power supply was designed to convert the 7.2v from the LiPo batteries to 5v for powering the car’s logic systems. The power supply is also capable of measuring battery power, voltage and current. The power supply is implemented using a LM2596-5.0 buck regulator IC, and an INA226 power monitoring IC. The power supply can supply the Raspberry Pi 4, which requires 5V at 3A as well as the ATMEGA328 board and other accessories. 

   #+caption: Power Supply schematic.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/powersupply_schematic.png]]

For the design of the power supply, a TI LM2596-5.0 “Simple Switcher” buck converter was chosen because of its efficiency, 3A output and ability to accept an input voltage as low as 7v. Originally a LM7805 based design with a bypass transistor was considered, but it would have been much less efficient. This would have reduced battery runtime and require a large heatsink which would have added weight. The values of L1, C1 and C2 were chosen based on the LM2596’s datasheet. The output current was assumed to be 3A, and the maximum input voltage as 12v (providing the ability to operate using a 3 cell LiPo if needed). 

The inductor L1 is a Bourns SRP1038A-220M which is shielded and has a saturation current of 5A. Since the components are in close proximity a shielded inductor is needed to prevent EMI from affecting the feedback line of the LM2596 (Pin 4) as well as the INA226 and I2C lines. The capacitors C1 and C2 are Nichicon aluminum polymer electrolytics, which have a very low (30 mΩ) ESR (equivalent series resistance). Low ESR is critical in a buck converter design because of the high current transients created by the switching. A low ESR allows the capacitor to charge and discharge faster to react to these transients. Diode D1 is a 50WQ04 Schottky diode which was used because of its fast switching time and low voltage drop.

For the power measurements, a TI INA226 current and power monitor was used because of its Linux driver support. The INA226 communicates with the Raspberry Pi over I2C, with R1 and R2 functioning as pull-up resistors. The INA226 measures current using a shunt resistor and measuring the voltage across it. The resistor’s value is programmed in at startup and from there an accurate current measurement can be taken. The shunt resistor Rshunt is a 0.002Ω 1% resistor as recommended in the INA226 datasheet.

   #+caption: Power Supply PCB layout.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/pcb_layout.png]]

Since the buck converter operates at a frequency of about 150kHz and used many surface mounted components, a custom PCB (printed circuit board) was designed using KiCad. The power supply was originally constructed on a protoboard (without the INA226 power measurement IC) and while it was somewhat functional it had stability issues and the output was limited to about 2A at 5V. The custom PCB eliminated all of these issues as well as creating a more mechanically robust design. 

High currents and frequencies are present in the power supply, so a ground plane design was used for the PCB. The back side of the board (shown in green) is copper filled and used as the ground connection for all components. Components on the front side of the board are connected to the ground plane using through-hole vias, which are holes drilled and electroplated through the board. The ground plane is also used as a heatsink for the LM2596 buck controller IC. Multiple vias were placed on the heatsink pad of the device to help conduct heat and serve as a ground connection. Thicker traces and shorter trace lengths are used for high current paths.

   #+caption: Power Supply PCB Before Assembly.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/powersupply_pcb.jpg]]

The PCB’s were manufactured by OSHPark, and all components were hand soldered. The larger components such as the inductor, diode and buck regulator were hot air soldered and the smaller components were soldered using a fine soldering iron tip. Solder wick was used to remove excess solder and a few solder bridges between INA226 pins.

*** Reading Power Supply Data in Linux

To measure the battery voltage and power consumption, a TI INA226 power monitoring IC was added to the power supply design. Linux includes a driver to read data from this device, and in order to use it on the Raspberry PI configuration changes need to be made. Since the Raspberry Pi doesn’t support hardware autodetection on any interface except USB, a system known as device tree is used to describe the system’s hardware configuration. The device tree provides information on all the system’s hardware, such as the addresses, registers, driver parameters and other information. The device tree is read by the Linux kernel at boot and then loads the required drivers and their parameters.

#+BEGIN_SRC emacs-lisp
/dts-v1/;
/plugin/;
/ {
	fragment@0 {
		target = <&i2c1>;
		__overlay__ {
			status = "okay";
			ina226@40 {	
				compatible = "ti,ina226";
				reg = <0x40>;
				shunt-resistor = <2000>;
			};
		};
	};
};
#+END_SRC


To add support for the INA226 a device tree overlay needed to be created to insert it into the system’s device tree. The contents of this file are shown above. The bus that the INA226 is attached to is defined with ~target = <&i2c1>~, the driver is set with ~compatible = 'ti,ina226'~ and the address with ~reg = <0x40>~. The shunt resistor value is set with ~shunt-resistor = <2000>~, with the resistance value in micro-ohms. The shunt resistor value is the resistance of the current shunt connected to the INA226, which is used for current and power calculations. In this case the current shunt’s resistance is 0.02Ω. The device tree overlay is enabled in the Raspberry Pi’s ~/boot/config.txt~ file. 

Once the driver is set up the voltage, power and current measurements can be accessed by any Linux program. The ~sensors~ utility can be used to display these values.

** Problems

*** Vehicle Issues
**** Motor and Drivetrain Issues

Originally, the vehicle was intended to use a brushless motor and speed controller. There were issues with the brushless speed controller, so a brushless motor and speed controller were used instead. There were also issues getting the motor and center gear to mesh correctly, the motor kept shifting out of position. This was fixed by tightening the motor mounting screws. The 3D printed driveshaft coupling pieces broke a few times and the original center gear was warped. These pieces were reprinted in carbon fiber PLA. 

**** Mounting and Fitment Issues

The original steering servo, a Hitec HS-422 didn't fit in the steering servo mount. Since the base plate of the car was already printed, it couldn't be enlarged to fit the servo without the screw holes not lining up. Eventually another servo was found which was small enough to fit the mount. Another issue was encounterd when the Raspberry Pi 2 was replaced with a Raspberry Pi 4. The mounting holes on the Raspberry Pi are 1.9 mm in diameter but the smallest mounting hardware was 2 mm. The holes were drilled out to fit the mounting hardware.

Another issue with the car was that since the body was slightly narrower than the original plans, the steering tie rods were slightly longer than needed. This caused the front wheels to angle in slightly. Shorter tie rods were printed but the wheels still had the same issue. Reprinting them again a few mm shorter would solve this issue.

*** Power Supply Issues

There were a few issues with the power supply during the development process. The original prototype of the power supply was built on a protoboard using through hole components. The inductor originally used for this design had the wrong value (68 uH vs 22 uH). Since this was a large toroidal inductor, the problem was resolved by taking turns off th inductor core until it measured at 22 uH. This iteration had stability issues where the power supply output voltage would randomly drop, even with no load. This iteration also had a max output current of about 1.5A. These issues were determined to be caused by the long lead lengths and EMI problems from the protoboard construction. 

There was also a few issues with the second version mainly related to PCB layout. The USB port’s power and ground lines were swapped, assuming it was top mounted. The solution to this problem was to desolder the port and install it upside down on the bottom of the board. Another issue was that the negative lead of the input capacitor (C1 on power supply schematic) was not connected to the ground plane, or anything else. The solution to this was to scrape off some solder mask from the ground plane and bridge the connection with solder.

*** Remote Shutoff Issues

A few problems were encountered with the remote shutoff system. With the original circuit, a JFET was used to drive the power MOSFET's gate. Sudden throttle changes and using the braking feature would cause the Xbee to reset, thus cutting power to the ESC. A decoupling capacitor was added to the Xbee power terminals, but this didn't solve the issue. The JFET was replaced with an optocoupler which electrically isolated the Xbee and power circuits. This solved the resetting issue, but the Xbee would still shut off ESC power after 60 seconds. This turned out to be a tim eout issue because the remote Xbee would only transmit when the switch's position was changed and the receiving ESC would time out after not receiving any transmission. After changing the Xbee programming to transmit every 10 ms this issue was solved.

* Test Results
*** Autonomous Driving Tests
   #+caption: Vehicle navigating the wide section of test track.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/test_track.png]]

In order to test the car’s autonomous driving capabilities, a test track was constructed. The lines for the testing track were marked with two parallel strips of blue masking tape. Two different widths were used for the track, 12 and 24 inches apart (based on the 12”x12” floor tiles). 
   #+caption: Vehicle navigating the narrow section of test track.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/test_track_narrow.png]]

The vehicle was able to successfully navigate the test track multiple times. It did leave the track a couple of times during testing, and with more time these issues could be resolved. The vehicle could handle corners and varying track widths, as well as merging from the wide track to the narrow one. 
  
*** OpenCV Lane Detection Testing Results
*** ATMEGA328 Firmware Testing Results


The ATMEGA328 firmware was tested in two parts, first testing the I2C interface itself and then verifying that the servo and throttle could be controlled using I2C commands. While the ATMEGA328 was originally intended to function as a PID controller as well, this function was eliminated due to a lack of development time.

For the first part of firmware testing, the ATMEGA was tested to ensure it would respond to its own I2C address. The ATMEGA was connected to the Raspberry Pi’s I2C pins through a level converter, and the Linux utility “i2cdetect” was used to scan for I2C devices. This utility tries each possible I2C address, and shows the addresses of the devices that respond. An example of this is shown in figure 1.1.2-1, with the ATMEGA using I2C address 0x32.
#+caption: Results of running ‘i2cdetect’ command while three devices were connected to the Raspberry Pi’s I2C bus.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/i2cdetect.png]]


During this testing, a few issues with the I2C controller were encountered. The first time “i2cdetect” was ran, the results were as shown above, with the ATMEGA responding to its own address and the other devices were able to respond as well. The second time it was run the ATMEGA held the data line to ground and no I2C communication was possible. When the ATMEGA was reset, the same issue would occur with a correct response the first time and a failure for all subsequent tries. This issue was found to be in an open source I2C library used on the ATMEGA which was not properly clearing the I2C interrupt bit. Once this issue was resolved the ATMEGA reliably responded to its I2C address.

For the next phase of testing the ATMEGA firmware was modified to print all data received over I2C to the USART. A small C++ program called “i2c-test” was written to send data to the ATMEGA from the Raspberry Pi. When this test was performed, there was a minor issue with the ATMEGA firmware expecting a newline character (0x12) but “i2c-test” sending a null character (0x0) instead. Once this was fixed, the firmware performed as expected with all data sent over I2C being printed to the USART console.
The final stage of testing was done to ensure that throttle and servo control over I2C were possible. The car was placed onto a stand and the motor speed controller and servo were connected to the ATMEGA board. The “i2c-test” code was used to send values for the throttle and servo angle. When this was tested the motor and servo responded as expected.
*** Power Supply Testing Results

Once the power supply was assembled, the first test was a load test to ensure that the power supply was capable of providing 3A at 5v with an input voltage of 7.4v (the lowest anticipated battery voltage). The ripple on the output of the power supply was also measured during load testing to ensure that it was less than 200 mV under all load conditions. Then the power monitoring circuit was connected to the Raspberry Pi over I2C and tested for functionality and accuracy.

   #+caption: Results of load testing, showing 3.4A current output at 5v with 7.4v input voltage
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/powersupply_load_test.jpg]]

   #+caption: Results of ripple testing with a 3A load and 7.4v input voltage
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/powersupply_test_ripple.png]]

For the load test, the power supply was connected to a bench power supply (set to 7.4v) and the output terminals were connected to a load resistor. The voltage and current were measured at both the input and output. An oscilloscope probe, set to AC coupling was also connected to the output to measure ripple. The maximum current delivered by the power supply was 3.4A while maintaining a 5v output. Any higher current would trigger the overcurrent protection mode on the power supply. The ripple with a 3A load was measured to be 201 mV.
   #+caption: Results of running “sensors” command, showing the voltage, current and power measurements from the power supply
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/powersupply_test_i2c.png]]

The next phase of power supply testing was to ensure that the current and power monitoring section was functional. The power supply’s I2C lines were connected to the Raspberry Pi through a level converter, and the Linux driver for the power monitoring chip was loaded. The Linux utility “sensors” was used to display the measurements. The measurements were verified with a multimeter and were within 0.01 of the multimeter reading for both current and voltage measurements.


* Design Documentation (Appendix)
** System Hardware Schematic
[[./figure/full_schematic.png]]

** INA226 Device Tree Overlay (ina226.dts)
#+BEGIN_SRC emacs-lisp
/dts-v1/;
/plugin/;
/ {
	fragment@0 {
		target = <&i2c1>;
		__overlay__ {
			status = "okay";
			ina226@40 {	
				compatible = "ti,ina226";
				reg = <0x40>;
				shunt-resistor = <2000>;
			};
		};
	};
};
#+END_SRC

** Raspberry Pi Boot Configuration (/boot/config.txt)

#+BEGIN_SRC emacs-lisp
# See /boot/overlays/README for all available options

gpu_mem=64
initramfs initramfs-linux.img followkernel
dtparam=i2c1=on
dtparam=i2c_arm=on
disable_overscan=1
dtoverlay=ina226
hdmi_force_hotplug=1 
dtoverlay=gpio-shutdown,gpio_pin=5
#+END_SRC

** ATMEGEA Vehicle Interface Controller
*** full.cpp
#+BEGIN_SRC emacs-lisp
#include <avr/io.h>
#include "String.hpp"
#include "usart.hpp"
#include <stdint.h>
#include "car.hpp"
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "usart.hpp"
#include "twi.hpp"
#include <avr/interrupt.h>

constexpr uint16_t bufferCapacity = 10;
constexpr Bounds<uint16_t> steeringAngleBounds = {50, 130};
Clamp steeringClamper = Clamp<uint16_t>::makeFromBounds(steeringAngleBounds);

void handler(uint8_t* rxbuffer, int twi_txBufferIndex);

void stateChange(String<bufferCapacity> state) {
    if (state == "+stop")
        car::stop();
}

int main() {
	twi_init();
	twi_attachSlaveRxEvent(handler);
	twi_setAddress(0x32);

    usart::beginAtBaud(9600);
    usart::print("RUNNING");
    car::start();
    
    sei();
 
	while(1) {}
}

void handler(uint8_t* rxbuffer, int twi_txBufferIndex) {
    char* message = reinterpret_cast<char*>(rxbuffer);
    //usart::print(message);
    if (message[0] == '+') stateChange(message);
    else if (isdigit(message[0])) {
        uint16_t steeringAngle = atoi(message);
        uint16_t micros = steeringClamper.mirrorMapValueToBounds(steeringAngle, car::servo::microsBounds);
        
        char steeringMessage[10];
        itoa(micros, steeringMessage, 10);
        usart::print(message);
        usart::print(", ");
        usart::print(steeringMessage);
        usart::print("\n");
        car::servo::setMicros(micros);
        //car::servo::setMirroredPositionFromBounds(steeringAngle, steeringAngleBounds);
        //car::esc::setMicrosForward(car::esc::upperBoundMicros-10);
    }
}

#+END_SRC

*** twi.cpp
#+BEGIN_SRC emacs-lisp
#include <math.h>
#include <stdlib.h>
#include <inttypes.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <compat/twi.h>

#ifndef cbi
#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
#endif

#ifndef sbi
#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
#endif

#include "twi.hpp"

static volatile uint8_t twi_state;
static volatile uint8_t twi_slarw;
static volatile uint8_t twi_sendStop;			// should the transaction end with a stop
static volatile uint8_t twi_inRepStart;			// in the middle of a repeated start

static void (*twi_onSlaveTransmit)(void);
static void (*twi_onSlaveReceive)(uint8_t*, int);

static uint8_t twi_masterBuffer[TWI_BUFFER_LENGTH];
static volatile uint8_t twi_masterBufferIndex;
static volatile uint8_t twi_masterBufferLength;

static uint8_t twi_txBuffer[TWI_BUFFER_LENGTH];
static volatile uint8_t twi_txBufferIndex;
static volatile uint8_t twi_txBufferLength;

static uint8_t twi_rxBuffer[TWI_BUFFER_LENGTH];
static volatile uint8_t twi_rxBufferIndex;

static volatile uint8_t twi_error;

/* 
 * Function twi_init
 * Desc     readys twi pins and sets twi bitrate
 * Input    none
 * Output   none
 */
void twi_init(void)
{
  // initialize state
  twi_state = TWI_READY;
  twi_sendStop = true;		// default value
  twi_inRepStart = false;
  
  // activate internal pullups for twi.
  //digitalWrite(SDA, 1);
  //digitalWrite(SCL, 1);

  // initialize twi prescaler and bit rate
  cbi(TWSR, TWPS0);
  cbi(TWSR, TWPS1);
  TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;

  /* twi bit rate formula from atmega128 manual pg 204
  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))
  note: TWBR should be 10 or higher for master mode
  It is 72 for a 16mhz Wiring board with 100kHz TWI */

  // enable twi module, acks, and twi interrupt
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);
}

/* 
 * Function twi_disable
 * Desc     disables twi pins
 * Input    none
 * Output   none
 */
void twi_disable(void)
{
  // disable twi module, acks, and twi interrupt
  TWCR &= ~(_BV(TWEN) | _BV(TWIE) | _BV(TWEA));

  // deactivate internal pullups for twi.
  //digitalWrite(SDA, 0);
  //digitalWrite(SCL, 0);
}

/* 
 * Function twi_slaveInit
 * Desc     sets slave address and enables interrupt
 * Input    none
 * Output   none
 */
void twi_setAddress(uint8_t address)
{
  // set twi slave address (skip over TWGCE bit)
  TWAR = address << 1;
}

/* 
 * Function twi_setClock
 * Desc     sets twi bit rate
 * Input    Clock Frequency
 * Output   none
 */
void twi_setFrequency(uint32_t frequency)
{
  TWBR = ((F_CPU / frequency) - 16) / 2;
  
  /* twi bit rate formula from atmega128 manual pg 204
  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))
  note: TWBR should be 10 or higher for master mode
  It is 72 for a 16mhz Wiring board with 100kHz TWI */
}

/* 
 * Function twi_readFrom
 * Desc     attempts to become twi bus master and read a
 *          series of bytes from a device on the bus
 * Input    address: 7bit i2c device address
 *          data: pointer to byte array
 *          length: number of bytes to read into array
 *          sendStop: Boolean indicating whether to send a stop at the end
 * Output   number of bytes read
 */
uint8_t twi_readFrom(uint8_t address, uint8_t* data, uint8_t length, uint8_t sendStop)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < length){
    return 0;
  }

  // wait until twi is ready, become master receiver
  while(TWI_READY != twi_state){
    continue;
  }
  twi_state = TWI_MRX;
  twi_sendStop = sendStop;
  // reset error state (0xFF.. no error occured)
  twi_error = 0xFF;

  // initialize buffer iteration vars
  twi_masterBufferIndex = 0;
  twi_masterBufferLength = length-1;  // This is not intuitive, read on...
  // On receive, the previously configured ACK/NACK setting is transmitted in
  // response to the received byte before the interrupt is signalled. 
  // Therefor we must actually set NACK when the _next_ to last byte is
  // received, causing that NACK to be sent in response to receiving the last
  // expected byte of data.

  // build sla+w, slave device address + w bit
  twi_slarw = TW_READ;
  twi_slarw |= address << 1;

  if (true == twi_inRepStart) {
    // if we're in the repeated start state, then we've already sent the start,
    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
    // We need to remove ourselves from the repeated start state before we enable interrupts,
    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
    // up. Also, don't enable the START interrupt. There may be one pending from the 
    // repeated start that we sent ourselves, and that would really confuse things.
    twi_inRepStart = false;			// remember, we're dealing with an ASYNC ISR
    do {
      TWDR = twi_slarw;
    } while(TWCR & _BV(TWWC));
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
  }
  else
    // send start condition
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);

  // wait for read operation to complete
  while(TWI_MRX == twi_state){
    continue;
  }

  if (twi_masterBufferIndex < length)
    length = twi_masterBufferIndex;

  // copy twi buffer to data
  for(i = 0; i < length; ++i){
    data[i] = twi_masterBuffer[i];
  }
	
  return length;
}

/* 
 * Function twi_writeTo
 * Desc     attempts to become twi bus master and write a
 *          series of bytes to a device on the bus
 * Input    address: 7bit i2c device address
 *          data: pointer to byte array
 *          length: number of bytes in array
 *          wait: boolean indicating to wait for write or not
 *          sendStop: boolean indicating whether or not to send a stop at the end
 * Output   0 .. success
 *          1 .. length to long for buffer
 *          2 .. address send, NACK received
 *          3 .. data send, NACK received
 *          4 .. other twi error (lost bus arbitration, bus error, ..)
 */
uint8_t twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait, uint8_t sendStop)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < length){
    return 1;
  }

  // wait until twi is ready, become master transmitter
  while(TWI_READY != twi_state){
    continue;
  }
  twi_state = TWI_MTX;
  twi_sendStop = sendStop;
  // reset error state (0xFF.. no error occured)
  twi_error = 0xFF;

  // initialize buffer iteration vars
  twi_masterBufferIndex = 0;
  twi_masterBufferLength = length;
  
  // copy data to twi buffer
  for(i = 0; i < length; ++i){
    twi_masterBuffer[i] = data[i];
  }
  
  // build sla+w, slave device address + w bit
  twi_slarw = TW_WRITE;
  twi_slarw |= address << 1;
  
  // if we're in a repeated start, then we've already sent the START
  // in the ISR. Don't do it again.
  //
  if (true == twi_inRepStart) {
    // if we're in the repeated start state, then we've already sent the start,
    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
    // We need to remove ourselves from the repeated start state before we enable interrupts,
    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
    // up. Also, don't enable the START interrupt. There may be one pending from the 
    // repeated start that we sent outselves, and that would really confuse things.
    twi_inRepStart = false;			// remember, we're dealing with an ASYNC ISR
    do {
      TWDR = twi_slarw;				
    } while(TWCR & _BV(TWWC));
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
  }
  else
    // send start condition
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA);	// enable INTs

  // wait for write operation to complete
  while(wait && (TWI_MTX == twi_state)){
    continue;
  }
  
  if (twi_error == 0xFF)
    return 0;	// success
  else if (twi_error == TW_MT_SLA_NACK)
    return 2;	// error: address send, nack received
  else if (twi_error == TW_MT_DATA_NACK)
    return 3;	// error: data send, nack received
  else
    return 4;	// other twi error
}

/* 
 * Function twi_transmit
 * Desc     fills slave tx buffer with data
 *          must be called in slave tx event callback
 * Input    data: pointer to byte array
 *          length: number of bytes in array
 * Output   1 length too long for buffer
 *          2 not slave transmitter
 *          0 ok
 */
uint8_t twi_transmit(const uint8_t* data, uint8_t length)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
    return 1;
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
    return 2;
  }
  
  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;
  
  return 0;
}

/* 
 * Function twi_attachSlaveRxEvent
 * Desc     sets function called before a slave read operation
 * Input    function: callback function to use
 * Output   none
 */
void twi_attachSlaveRxEvent( void (*function)(uint8_t*, int) )
{
  twi_onSlaveReceive = function;
}

/* 
 * Function twi_attachSlaveTxEvent
 * Desc     sets function called before a slave write operation
 * Input    function: callback function to use
 * Output   none
 */
void twi_attachSlaveTxEvent( void (*function)(void) )
{
  twi_onSlaveTransmit = function;
}

/* 
 * Function twi_reply
 * Desc     sends byte or readys receive line
 * Input    ack: byte indicating to ack or to nack
 * Output   none
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
  }
}

/* 
 * Function twi_stop
 * Desc     relinquishes bus master status
 * Input    none
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
}

/* 
 * Function twi_releaseBus
 * Desc     releases bus control
 * Input    none
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);

  // update twi state
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
      twi_reply(1);
      break;

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
        twi_reply(1);
      }else{
	if (twi_sendStop)
          twi_stop();
	else {
	  twi_inRepStart = true;	// we're gonna send the START
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
	  twi_state = TWI_READY;
	}
      }
      break;
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
      twi_stop();
      break;
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
      twi_releaseBus();
      break;

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
        twi_reply(1);
      }else{
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
	if (twi_sendStop)
          twi_stop();
	else {
	  twi_inRepStart = true;	// we're gonna send the START
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
	  twi_state = TWI_READY;
	}    
	break;
    case TW_MR_SLA_NACK: // address sent, nack received
      twi_stop();
      break;
    // TW_MR_ARB_LOST handled by TW_MT_ARB_LOST case

    // Slave Receiver
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
        twi_reply(1);
      }else{
        // otherwise nack
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // ack future responses and leave slave receiver state
      twi_releaseBus();
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
      }
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
      break;
    case TW_SR_DATA_NACK:       // data received, returned nack
    case TW_SR_GCALL_DATA_NACK: // data received generally, returned nack
      // nack back at master
      twi_reply(0);
      break;
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
        twi_txBufferLength = 1;
        twi_txBuffer[0] = 0x00;
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
        twi_reply(1);
      }else{
        twi_reply(0);
      }
      break;
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
      break;

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
      twi_stop();
      break;
  }
}


#+END_SRC

*** twi.hpp
#+BEGIN_SRC emacs-lisp
#ifndef twi_h
#define twi_h

  #include <inttypes.h>

  //#define ATMEGA8

  #ifndef TWI_FREQ
  #define TWI_FREQ 100000L
  #endif

  #ifndef TWI_BUFFER_LENGTH
  #define TWI_BUFFER_LENGTH 32
  #endif

  #define TWI_READY 0
  #define TWI_MRX   1
  #define TWI_MTX   2
  #define TWI_SRX   3
  #define TWI_STX   4
  
  void twi_init(void);
  void twi_disable(void);
  void twi_setAddress(uint8_t);
  void twi_setFrequency(uint32_t);
  uint8_t twi_readFrom(uint8_t, uint8_t*, uint8_t, uint8_t);
  uint8_t twi_writeTo(uint8_t, uint8_t*, uint8_t, uint8_t, uint8_t);
  uint8_t twi_transmit(const uint8_t*, uint8_t);
  void twi_attachSlaveRxEvent( void (*)(uint8_t*, int) );
  void twi_attachSlaveTxEvent( void (*)(void) );
  void twi_reply(uint8_t);
  void twi_stop(void);
  void twi_releaseBus(void);

#endif
#+END_SRC

*** car.hpp
#+BEGIN_SRC emacs-lisp
#ifndef CAR_HPP
#define CAR_HPP

#include "Clamp.hpp"
#include "dual_servo.hpp"
#include <util/delay.h>

//Arduino Uno Pins: 9 (ESC), 10 (Servo)

namespace car::servo {
    constexpr uint16_t rightBoundMicros = 1150;
    constexpr uint16_t leftBoundMicros = 1850;
    constexpr uint16_t centerMicros = 1500;
    constexpr Bounds<uint16_t> microsBounds = {
        .lower = rightBoundMicros,
        .upper = leftBoundMicros};

    uint16_t currentMicros;     
    
    namespace {
        Clamp clamper = Clamp<uint16_t>::makeFromBounds(microsBounds);
    }
    
    void setMicros(uint16_t micros) {
        dual_servo::setMicrosB(currentMicros = clamper.clamp(micros));
    }

    void setPositionFromBounds(uint16_t position, Bounds<uint16_t> bounds) {
        Clamp positionClamper = Clamp<uint16_t>::makeFromBounds(bounds);
        uint16_t micros = positionClamper.mapValueToBounds(position, microsBounds);
        setMicros(micros);
    }

    void setMirroredPositionFromBounds(uint16_t position, Bounds<uint16_t> bounds) {
        Clamp positionClamper = Clamp<uint16_t>::makeFromBounds(bounds);
        uint16_t micros = positionClamper.mirrorMapValueToBounds(position, microsBounds);
        setMicros(micros);
    }
    
    void center() {
        dual_servo::setMicrosB(currentMicros = centerMicros);
    }

    void increment(uint16_t increment) {
        setMicros(currentMicros += increment);
    }

    bool isAtLeftBound() { return currentMicros == microsBounds.upper; }
    bool isAtRightBound() { return currentMicros == microsBounds.lower; }
    bool isCentered() { return currentMicros == centerMicros; }
}

namespace car::esc {
    constexpr uint16_t upperBoundMicros = 1600;
    constexpr uint16_t lowerBoundMicros = 1420;
    constexpr uint16_t centerMicros = 1500;
    constexpr Bounds<uint16_t> forwardMicrosBounds = {
        .lower = centerMicros,
        .upper = upperBoundMicros};
    constexpr Bounds<uint16_t> reverseMicrosBounds = {
        .lower = lowerBoundMicros,
        .upper = centerMicros};

    uint16_t currentMicros; 
    
    namespace {
        Clamp forwardClamper = Clamp<uint16_t>::makeFromBounds(forwardMicrosBounds);
        Clamp reverseClamper = Clamp<uint16_t>::makeFromBounds(reverseMicrosBounds);

        void setMicrosToArm() {
            dual_servo::setMicrosA(currentMicros = centerMicros);
        }
    }
    
    void setMicrosForward(uint16_t micros) {
        dual_servo::setMicrosA(currentMicros = forwardClamper.clamp(micros));
    }
    
    void setMicrosReverse(uint16_t micros) {
        dual_servo::setMicrosA(currentMicros = reverseClamper.clamp(micros));
    }

    void arm() {
        setMicrosToArm();
        _delay_ms(2000);
    }

    void brake() {
        dual_servo::setMicrosA(currentMicros = lowerBoundMicros);
        _delay_ms(1000);
        dual_servo::setMicrosA(currentMicros = centerMicros);
    }

    void increment(uint16_t increment) {
        currentMicros += increment;
        setMicrosForward(currentMicros);
    }

    bool isAtUpperBound() { return currentMicros == forwardMicrosBounds.upper; }
    bool isAtLowerBound() { return currentMicros == reverseMicrosBounds.lower; }
    bool isCentered() { return currentMicros == centerMicros; }
}

namespace car {
    void start() {
        dual_servo::start();
        car::servo::center();
        car::esc::arm();
    }

    void stop() {
        car::servo::center();
        car::esc::brake();
    }
}

#endif

#+END_SRC

*** dualservo.hpp
#+BEGIN_SRC emacs-lisp
#ifndef DUALSERVO_HPP
#define DUALSERVO_HPP

#include <avr/io.h>
#include "cycles.hpp"

namespace dual_servo {
    void start() {
        DDRB |= 1 << PINB1; //Output from OCR1A (pin 9 Arduino Uno)
        DDRB |= 1 << PINB2; //Output from OCR1B (pin 10 Arduino Uno) 

        TCCR1A |=
            1 << WGM11 | //PWM Mode 14 (1/3)
            1 << COM1A1 | //Non-Inverting Mode
            1 << COM1B1; //Non-Inverting Mode
    
        TCCR1B |=
            1 << WGM12 | //PWM Mode 14 (2/3)
            1 << WGM13 | //PWM Mode 14 (3/3)
            1 << CS11; //Prescaler: 8

        cycles::prescaler = 8;
        ICR1 = cycles::fromHertz(50)-1;
    }

    void setMicrosA(uint16_t micros) {    
        OCR1A = cycles::fromMicros(micros);
    }

    void setMicrosB(uint16_t micros) {
        OCR1B = cycles::fromMicros(micros);
    }
}

#endif

#+END_SRC

*** Clamp.hpp
#+BEGIN_SRC emacs-lisp
#ifndef CLAMP_HPP
#define CLAMP_HPP

#include <stdint.h>

template<typename T>
struct Bounds {
    T lower;
    T upper;
};

template<typename T>
class Clamp {
    Bounds<T> bounds;

public:
    constexpr static Clamp<T> makeFromBounds(Bounds<T> bounds) {
        return Clamp(bounds);
    }

    constexpr explicit Clamp(Bounds<T> bounds): bounds{bounds} {}

    T clamp(T value) {
        return (value < bounds.lower) ? bounds.lower :
            (value > bounds.upper) ? bounds.upper:
            value;
    }
    
    T mapValueToBounds(T value, Bounds<T> other) {
        T otherRange = other.upper - other.lower;
        T thisRange = bounds.upper - bounds.lower;
        
        return other.lower + otherRange*(clamp(value) - bounds.lower)/thisRange;
    }

    T mirrorMapValueToBounds(T value, Bounds<T> other) {
        T mirroredValue = bounds.upper-value + bounds.lower;
        return mapValueToBounds(mirroredValue, other);
    }
    
    Clamp() {}
};

#endif

#+END_SRC

*** cycles.hpp
#+BEGIN_SRC emacs-lisp
#ifndef CYCLES_HPP
#define CYCLES_HPP

namespace cycles {
    constexpr uint32_t clockFrequency = F_CPU;
    static uint8_t prescaler;

    uint32_t fromMicros(uint16_t micros) {
        constexpr uint32_t unitConversion = 1E6;
        return (clockFrequency/unitConversion/prescaler) * micros;
    }

    uint32_t fromHertz(uint16_t hertz) {
        return clockFrequency/prescaler/hertz;
    }    
}

#endif

#+END_SRC

*** Makefile
#+BEGIN_SRC emacs-lisp
subdirs = $(shell find app -mindepth 1 -maxdepth 1 -type d)
all:
	make -C common
	for dir in $(subdirs); do make -C $$dir || exit 1; done

clean:
	make -C common $@
	for dir in $(subdirs); do make -C $$dir $@; done

test:
	make -C common $@

#+END_SRC

** OpenCV Lane Detection (Raspberry Pi)
*** video.py
#+BEGIN_SRC emacs-lisp
import numpy
import cv2
import math
import sys

def detect_edges(frame):
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    lower_blue = numpy.array([60, 40, 40])
    upper_blue = numpy.array([150, 255, 255])
    mask = cv2.inRange(hsv, lower_blue, upper_blue)
    edges = cv2.Canny(mask, 200, 400)
    return edges
def display_lines(frame, lines, line_color=(0, 255, 0), line_width=2):
    line_image = numpy.zeros_like(frame)
    if lines is not None:
        for line in lines:
            for x1, y1, x2, y2 in line:
                cv2.line(line_image, (x1, y1), (x2, y2), line_color, line_width)
    line_image = cv2.addWeighted(frame, 0.8, line_image, 1, 1)
    return line_image
def region_of_interest(edges):
    height, width = edges.shape
    mask = numpy.zeros_like(edges)

    # only focus bottom half of the screen
    polygon = numpy.array([[
        (0, height * 1 / 2),
        (width, height * 1 / 2),
        (width, height),
        (0, height),
    ]], numpy.int32)

    cv2.fillPoly(mask, polygon, 255)
    cropped_edges = cv2.bitwise_and(edges, mask)
    return cropped_edges
def detect_line_segments(cropped_edges):
    # tuning min_threshold, minLineLength, maxLineGap is a trial and error process by hand
    rho = 1  # distance precision in pixel, i.e. 1 pixel
    angle = numpy.pi / 180  # angular precision in radian, i.e. 1 degree
    min_threshold = 10  # minimal of votes
    line_segments = cv2.HoughLinesP(cropped_edges, rho, angle, min_threshold, 
                                    numpy.array([]), minLineLength=8, maxLineGap=4)

    return line_segments
def make_points(frame, line):
    height, width, _ = frame.shape
    slope, intercept = line
    y1 = height  # bottom of the frame
    y2 = int(y1 * 1 / 2)  # make points from middle of the frame down

    # bound the coordinates within the frame
    x1 = max(-width, min(2 * width, int((y1 - intercept) / slope)))
    x2 = max(-width, min(2 * width, int((y2 - intercept) / slope)))
    return [[x1, y1, x2, y2]]

def average_slope_intercept(frame, line_segments):
    """
    This function combines line segments into one or two lane lines
    If all line slopes are < 0: then we only have detected left lane
    If all line slopes are > 0: then we only have detected right lane
    """
    lane_lines = []
    if line_segments is None:
        return lane_lines

    height, width, _ = frame.shape
    left_fit = []
    right_fit = []

    boundary = 1/3
    left_region_boundary = width * (1 - boundary)  # left lane line segment should be on left 2/3 of the screen
    right_region_boundary = width * boundary # right lane line segment should be on left 2/3 of the screen

    for line_segment in line_segments:
        for x1, y1, x2, y2 in line_segment:
            if x1 == x2:
                continue
            fit = numpy.polyfit((x1, x2), (y1, y2), 1)
            slope = fit[0]
            intercept = fit[1]
            if slope < 0:
                if x1 < left_region_boundary and x2 < left_region_boundary:
                    left_fit.append((slope, intercept))
            else:
                if x1 > right_region_boundary and x2 > right_region_boundary:
                    right_fit.append((slope, intercept))

    left_fit_average = numpy.average(left_fit, axis=0)
    if len(left_fit) > 0:
        lane_lines.append(make_points(frame, left_fit_average))

    right_fit_average = numpy.average(right_fit, axis=0)
    if len(right_fit) > 0:
        lane_lines.append(make_points(frame, right_fit_average))

    return lane_lines
def detect_lane(frame):

    edges = detect_edges(frame)
    cropped_edges = region_of_interest(edges)
    line_segments = detect_line_segments(cropped_edges)
    lane_lines = average_slope_intercept(frame, line_segments)
    
    return lane_lines
def display_heading_line(frame, steering_angle, line_color=(0, 0, 255), line_width=5 ):
    heading_image = numpy.zeros_like(frame)
    height, width, _ = frame.shape

    # figure out the heading line from steering angle
    # heading line (x1,y1) is always center bottom of the screen
    # (x2, y2) requires a bit of trigonometry

    steering_angle_radian = steering_angle / 180.0 * math.pi
    x1 = int(width / 2)
    y1 = height
    x2 = int(x1 - height / 2 / math.tan(steering_angle_radian))
    y2 = int(height / 2)
    
    cv2.putText(frame, f"{steering_angle} deg", (int(width/2) - 40, y2-10), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 0), 1, cv2.LINE_AA)
    cv2.line(heading_image, (x1, y1), (x2, y2), line_color, line_width)
    heading_image = cv2.addWeighted(frame, 0.8, heading_image, 1, 1)

    return heading_image
def stabilize_steering_angle(
          curr_steering_angle, 
          new_steering_angle, 
          num_of_lane_lines, 
          max_angle_deviation_two_lines=5, 
          max_angle_deviation_one_lane=1):
    """
    Using last steering angle to stabilize the steering angle
    if new angle is too different from current angle, 
    only turn by max_angle_deviation degrees
    """
    if num_of_lane_lines == 2 :
        # if both lane lines detected, then we can deviate more
        max_angle_deviation = max_angle_deviation_two_lines
    else :
        # if only one lane detected, don't deviate too much
        max_angle_deviation = max_angle_deviation_one_lane
    
    angle_deviation = new_steering_angle - curr_steering_angle
    if abs(angle_deviation) > max_angle_deviation:
        stabilized_steering_angle = int(curr_steering_angle
            + max_angle_deviation * angle_deviation / abs(angle_deviation))
    else:
        stabilized_steering_angle = new_steering_angle
    return stabilized_steering_angle

def getMp4Colorless(name: str, fps: int) -> cv2.VideoWriter:
    return cv2.VideoWriter(
        filename = f"{name}_{fps}fps.mp4",
        fourcc = cv2.VideoWriter_fourcc(*'X264'),
        fps = fps,
        frameSize = (640,480), 
        isColor = False)

def getMp4Color(name: str, fps: int) -> cv2.VideoWriter:
    return cv2.VideoWriter(
        filename = f"{name}_{fps}fps.mp4",
        fourcc = cv2.VideoWriter_fourcc(*'X264'),
        fps = fps,
        frameSize = (640,480), 
        isColor = True)


frame = cv2.imread(sys.argv[1])
lane_lines = detect_lane(frame)
height, width, _ = frame.shape

#2 lane detected
_, _, left_x2, _ = lane_lines[0][0]
_, _, right_x2, _ = lane_lines[1][0]
mid = int(width / 2)
x_offset = (left_x2 + right_x2) / 2 - mid
y_offset = int(height / 2)

#Only 1 lane detected
# x1, _, x2, _ = lane_lines[0][0]
# x_offset = x2 - x1
# y_offset = int(height / 2)

angle_to_mid_radian = math.atan(x_offset / y_offset)  # angle (in radian) to center vertical line
angle_to_mid_deg = int(angle_to_mid_radian * 180.0 / math.pi)  # angle (in degrees) to center vertical line
steering_angle = angle_to_mid_deg + 90  # this is the steering angle needed by picar front wheel

lane_lines_image = display_lines(frame, lane_lines)
cv2.imshow("lane lines", lane_lines_image)
cv2.imshow("", display_heading_line(frame, steering_angle))
cv2.waitKey(0)

#+END_SRC

** Web Status Page
*** index.html
#+BEGIN_SRC emacs-lisp
<!DOCTYPE HTML><html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="/highcharts.js"></script>
  <title>Pi Status</title>
  <link rel="icon" href="/favicon.jpg">
  <style>
    body {
      min-width: 310px;
    	max-width: 800px;
    	height: 400px;
      margin: 0 auto;
    }
    h2 {
      font-family: Arial;
      font-size: 2.5rem;
      text-align: center;
    }
  </style>
</head>
<body>
  <h2>Vehicle Data</h2>


</form>
  <h3>Pi Data</h3>
  <div id="chart-load" class="container"></div>
  <div id="chart-mem" class="container"></div>
  <div id="chart-temperature" class="container"></div>
  <h3>Power Supply Data</h3>
  <div id="chart-power" class="container"></div>
  <div id="chart-voltage" class="container"></div>
  <div id="chart-current" class="container"></div>

</body>
<script>
var chartC = new Highcharts.Chart({
  chart:{ renderTo : 'chart-temperature' },
  title: { text: 'Temperature' },
  series: [{
    name: 'CPU',
    showInLegend: true,
    data: [],
    color: '#eb5b34'
  }, {
    name: 'GPU',
    showInLegend: true,
    data: [],
    color: '#24f00a'
  }],
  plotOptions: {
    line: { animation: false,
      dataLabels: { enabled: true }
    },
    series: { color: '#059e8a' }
  },
  xAxis: { type: 'datetime',
    dateTimeLabelFormats: { second: '%H:%M:%S' }
  },
  yAxis: {
    title: { text: 'Temperature (C)' }
  },
  credits: { enabled: false }
});
setInterval(function ( ) {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      var x = (new Date()).getTime(),
          y = parseFloat(this.responseText);
      //console.log(this.responseText);
      if(chartC.series[0].data.length > 40) {
        chartC.series[0].addPoint([x, y], true, true, true);
      } else {
        chartC.series[0].addPoint([x, y], true, false, true);
      }
    }
  };
  xhttp.open("GET", "/temperature_c.php", true);
  xhttp.send();  
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      var x = (new Date()).getTime(),
          y = parseFloat(this.responseText);
      //console.log(this.responseText);
      if(chartC.series[1].data.length > 40) {
        chartC.series[1].addPoint([x, y], true, true, true);
      } else {
        chartC.series[1].addPoint([x, y], true, false, true);
      }
    }
  };
  xhttp.open("GET", "/temperature_g.php", true);
  xhttp.send();

}, 1000 ) ;

var chartL = new Highcharts.Chart({
  chart:{ renderTo : 'chart-load' },
  title: { text: 'System Load' },
  series: [{
    showInLegend: false,
    data: []
  }],
  plotOptions: {
    line: { animation: false,
      dataLabels: { enabled: true }
    },
    series: { color: '#059e8a' }
  },
  xAxis: { type: 'datetime',
    dateTimeLabelFormats: { second: '%H:%M:%S' }
  },
  yAxis: {
  },
  credits: { enabled: false }
});
setInterval(function ( ) {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      var x = (new Date()).getTime(),
          y = parseFloat(this.responseText);
      //console.log(this.responseText);
      if(chartL.series[0].data.length > 40) {
        chartL.series[0].addPoint([x, y], true, true, true);
      } else {
        chartL.series[0].addPoint([x, y], true, false, true);
      }
    }
  };
  xhttp.open("GET", "/load.php", true);
  xhttp.send();
}, 1000 ) ;

var chartM = new Highcharts.Chart({
  chart:{ renderTo : 'chart-mem' },
  title: { text: 'Memory' },
  series: [{
    name: 'Used Memory',
    color: '#00FF00',
    showInLegend: true,
    data: []
  }, {
  name: 'Free Memory',
  color: '#FF00FF',
  showInLegend: true,
  data: []
  }],
  plotOptions: {
    line: { animation: false,
      dataLabels: { enabled: true }
    },
    series: { color: '#059e8a' }
  },
  xAxis: { type: 'datetime',
    dateTimeLabelFormats: { second: '%H:%M:%S' }
  },
  yAxis: {
    title: {text: "Memory (Mb)" }
  },
  credits: { enabled: false }
});
setInterval(function ( ) {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      var x = (new Date()).getTime(),
          y = parseFloat(this.responseText);
      if(chartM.series[0].data.length > 40) {
        chartM.series[0].addPoint([x, y], true, true, true);
      } else {
        chartM.series[0].addPoint([x, y], true, false, true);
      }
    }
  };
  xhttp.open("GET", "/memory.php", true);
  xhttp.send();
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      var x = (new Date()).getTime(),
          y = parseFloat(this.responseText);
      if(chartM.series[1].data.length > 40) {
        chartM.series[1].addPoint([x, y], true, true, true);
      } else {
        chartM.series[1].addPoint([x, y], true, false, true);
      }
    }
  };
  xhttp.open("GET", "/memfree.php", true);
  xhttp.send();

}, 1000 ) ;


var chartT = new Highcharts.Chart({
  chart:{ renderTo : 'chart-power' },
  title: { text: 'Power' },
  series: [{
    showInLegend: false,
    data: []
  }],
  plotOptions: {
    line: { animation: false,
      dataLabels: { enabled: true }
    },
    series: { color: '#059e8a' }
  },
  xAxis: { type: 'datetime',
    dateTimeLabelFormats: { second: '%H:%M:%S' }
  },
  yAxis: {
    title: { text: 'Power (W)' }
  },
  credits: { enabled: false }
});
setInterval(function ( ) {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      var x = (new Date()).getTime(),
          y = parseFloat(this.responseText);
      //console.log(this.responseText);
      if(chartT.series[0].data.length > 40) {
        chartT.series[0].addPoint([x, y], true, true, true);
      } else {
        chartT.series[0].addPoint([x, y], true, false, true);
      }
    }
  };
  xhttp.open("GET", "/power.php", true);
  xhttp.send();
}, 1000 ) ;

var chartH = new Highcharts.Chart({
  chart:{ renderTo:'chart-voltage' },
  title: { text: 'Battery Voltage' },
  series: [{
    showInLegend: false,
    data: []
  }],
  plotOptions: {
    line: { animation: false,
      dataLabels: { enabled: true }
    }
  },
  xAxis: {
    type: 'datetime',
    dateTimeLabelFormats: { second: '%H:%M:%S' }
  },
  yAxis: {
    title: { text: 'Voltage (V)' }
  },
  credits: { enabled: false }
});
setInterval(function ( ) {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      var x = (new Date()).getTime(),
          y = parseFloat(this.responseText);
      //console.log(this.responseText);
      if(chartH.series[0].data.length > 40) {
        chartH.series[0].addPoint([x, y], true, true, true);
      } else {
        chartH.series[0].addPoint([x, y], true, false, true);
      }
    }
  };
  xhttp.open("GET", "/voltage.php", true);
  xhttp.send();
}, 1000 ) ;

var chartP = new Highcharts.Chart({
  chart:{ renderTo:'chart-current' },
  title: { text: 'Battery Current' },
  series: [{
    showInLegend: false,
    data: []
  }],
  plotOptions: {
    line: { animation: false,
      dataLabels: { enabled: true }
    },
    series: { color: '#18009c' }
  },
  xAxis: {
    type: 'datetime',
    dateTimeLabelFormats: { second: '%H:%M:%S' }
  },
  yAxis: {
    title: { text: 'Current (mA)' }
  },
  credits: { enabled: false }
});
setInterval(function ( ) {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      var x = (new Date()).getTime(),
          y = parseFloat(this.responseText);
      //console.log(this.responseText);
      if(chartP.series[0].data.length > 40) {
        chartP.series[0].addPoint([x, y], true, true, true);
      } else {
        chartP.series[0].addPoint([x, y], true, false, true);
      }
    }
  };
  xhttp.open("GET", "/current.php", true);
  xhttp.send();
}, 1000 ) ;
</script>
</html>
#+END_SRC

*** power.php
#+BEGIN_SRC emacs-lisp
<?php 
  
// Use ls command to shell_exec 
// function 
$output = shell_exec('(sensors | grep power)'); //'bash -c 'sensors');// | grep power | sed 's/[^0-9]*//g'''); 

$output = preg_replace('/^[^:]+:\s*/', '' ,$output); 

$output = preg_replace('/[^0-9^.]*/', '', $output); 

//$output2 = preg_replace( '[^0-9]*', '', $output); 
// Display the list of all file 
// and directory 
echo "$output"; 
?> 

#+END_SRC

*** load.php
#+BEGIN_SRC emacs-lisp
<?php 
  
// Use ls command to shell_exec 
// function 
$output = shell_exec('cat /proc/loadavg');  

$output = substr ( $output, 0, 4);

echo "$output"; 
?> 

#+END_SRC

*** temperature_c.php
#+BEGIN_SRC emacs-lisp
<?php 
  
// Use ls command to shell_exec 
// function 
$output = shell_exec('cat /sys/class/thermal/thermal_zone0/temp');  

$output = $output / 1000;

echo "$output"; 
?> 

#+END_SRC

*** temperature_g.php
#+BEGIN_SRC emacs-lisp
<?php 
  
// Use ls command to shell_exec 
// function 
$output = shell_exec('/opt/vc/bin/vcgencmd measure_temp');  

$output = preg_replace("/[^0-9]/", "",$output);

$output = $output / 10;

echo "$output"; 
?> 

#+END_SRC

*** voltage.php
#+BEGIN_SRC emacs-lisp
<?php `
  
// Use ls command to shell_exec 
// function 
$output = shell_exec('(sensors | grep in1)'); //'bash -c 'sensors');// | grep power | sed 's/[^0-9]*//g'''); 

$output = preg_replace('/^[^:]+:\s*/', '' ,$output); 

$output = preg_replace('/[^0-9^.]*/', '', $output); 

//$output2 = preg_replace( '[^0-9]*', '', $output); 
// Display the list of all file 
// and directory 
echo "$output"; 
?> 

#+END_SRC
