#+title: FrostAV Final Report
** Requirements Evaluation
*** Problem Domain Requirements
The main problem-domain requirements for this project are:
   1. Given a _lane_, the car must travel approximately parallel to it,
      such that the car stays within its _boundaries_ consistently,
      and, if the car is to accidentally leave it, it promptly
      returns.
   2. Given a _corner_, the car must turn, continuing from the car’s
      current _lane_ to the next, such that the car stays within its
      _boundaries_ consistently, and, if the car is to accidentally
      leave it, it promptly returns.
   3. Given an _obstacle_, the car must stop until it is moved
      further from the car, or it is removed from _circuit boundaries_.
   4. Given a _sign_, the car must respond to the event provided by it.
   5. Given a _circuit_, the car must complete a full loop.

   #+caption: An example _circuit_ which the car must navigate through.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/environment.png]]

The completed project is fully capable of meeting requirements 1, 2 and 5 and is unable to meet 3 and 4. The car can successfully navigate a straight path and recover from small excursions outside of the lane boundaries. It can also navigate corners and complete a circuit. Obstacle detection and sign detection was never implemented due to a lack of time.

*** Control System and Control Module Requirements
For the control system and control modules, the following requirements apply:
    The Control System shall:
   1. Interface with vehicle peripherals, such as, motors, servos,
      batteries, etc.
   2. Be the only system coupled to the vehicle. 
   3. Have a subset of Control Modules for each peripheral in need
      of control.

    Each Control Module shall:
   1. Encapsulate a single purpose, such that, one controller controls
      a single peripheral.
   2. Couple to a peripheral electronically, not mechanically.
   3. Be able to communicate with other controllers via a wired bus.
   4. Be able to communicate with non-controllers that depend on it,
      via a wired bus.
   5. Communicate with other controllers and non-controllers via a
      single shared wired bus.

All the control system and control module requirements were met, except for the requirement that each control module must control a single peripheral. In the final design, the ATMEGA328 is used for both servo and throttle control instead of having a separate module for each. Otherwise, the control system was able to successfully interface with the vehicle peripherals using control modules, and the control modules share a single I2C bus. All control modules can communicate with the Raspberry Pi, which runs the main control system, and with each other (even though this capability was not utilized for the final design).

*** Autonomy Requirements

The vehicle’s autonomy system shall:
   1. Not be directly coupled to the Vehicle Interface (section [[#vehicle-interface-requirements]]).
   2. Be able to fit on the vehicle.
   3. Allow the vehicle to navigate, as per section
      [[#problem-domain-requirements]], without user interaction.
   4. Be able to communicate with the Control System (section [[#Control System and Control Module Requirements]]).
The final design is capable of meeting all the autonomy requirements. The autonomy system can communicate with all modules that make up the control system, including communicating with multiple modules in quick succession. The system is not directly coupled to the vehicle interface, instead performing all vehicle functions using control modules. The system fits on the vehicle and allows the vehicle to navigate autonomously.

*** Vehicle Interface Requirements

The vehicle interface shall:
    1. Include a way for the vehicle to be turned on and off, such
       that, the vehicle receives no power to the _drive system_ or
       _logic_ when off.
    2. Include a way for the vehicle to have its _logic_ turned on,
       while the _drive system_ is off.
    3. Provide a battery peripheral that powers the _logic_.
    4. Provide a battery peripheral that powers the _drive system_.
    5. The total power consumption of the _logic_ and _drive system_
       cannot exceed the maximum capacity of the battery
       peripheral(s).
    6. Provide a peripheral that moves the vehicle.
    7. Provide a peripheral that steers the vehicle.
    8. Provide an electronic interface from each peripheral.

All vehicle interface requirements were met with the final design. The design meets requirements 1 and 2 with a power switch on the logic battery, and a power switch and remote cutoff on the drive battery. This allows the logic to be powered independently of the drive system. Requirements 3 and 4 are met with the inclusion of the logic and drive batteries as well as the logic power supply. The batteries and power supply allow all the logic and drive system modules to be powered. 

Requirement 5 is met by ensuring that the maximum power draw won’t exceed the batteries maximum rating. All of the batteries used in this design are rated at 30C or greater, which is a measure of a batteries maximum discharge rate. For the 5200 mAh drive battery, a 30C rating corresponds to a maximum output of 156 A. The ESC used to power the drive motor and servo is rated for a maximum of 60A, so the maximum potential current draw is well within the battery’s capabilities. The logic battery, which has a capacity of 2200 mAh and a discharge rating of 30C can supply a maximum of 66A. Since all logic is powered by the power supply (which has a current limiting function) the maximum current drawn from this battery will never exceed 3A. 

Requirements 6 and 7 are met by the ATMEGA328, the motor, ESC and steering servo. The ATMEGA328 controls the servo and ESC, and the ESC regulates the motor’s speed. These components allow the vehicle to be steered and moved by the autonomy system. Each peripheral also has an electronic interface. The ATMEGA328 communicates with the autonomy system, which is running on a Raspberry Pi using the I2C bus. The voltage and current draw of the logic battery are measured using the INA226 power monitoring chip built into the power supply and communicated to the autonomy system over the I2C bus.

*** Wireless Interface Requirements
    The Wireless Interface shall:
    1. Allow for wireless tunneling (e.g. via SSH)
    2. Be able to access a server.
    3. Provide bi-directional communication.

All of these requirements for the wireless system are met in the final design, using the Raspberry Pi 4’s integrated WiFi. The Wifi connection allows for SSH tunneling as well as providing a HTTP server. The system is also capable of connecting to a server using SSH tunneling. The Wifi is also fully capable of bi-directional communication.

** Additional Capabilities

During the development of the vehicle, a few additional capabilities and features were able to be implemented.

*** Status OLED Display

   #+caption: OLED display showing parameters.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/oled.jpg]]

A SSD1306 OLED display module was added to the design towards the end of Milestone 4, which allows easier monitoring of the Raspberry Pi and battery parameters. The display shows the current IP address of the Pi, the CPU load and temperature, memory usage, and the voltage, current draw and power use from the logic battery. 

This display has been useful in the development of the system because it allows important parameters to be monitored easily. Since the Clarkson University Wifi uses DHCP addresses, the Pi’s IP changes periodically. Since the IP is needed for accessing SSH and the Pi’s webserver this is a very useful parameter to have. The voltage monitoring serves as a low battery indication for the logic battery.

*** HTTP Status Monitoring

   #+caption: An example _circuit_ which the car must navigate through.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/web_screenshot.png]]

Similar to the OLED display, a web server was implemented on the Pi to monitor various parameters. The parameters monitored are the Pi’s CPU load, memory use, CPU and GPU temperature, and power, voltage and current from the logic battery. These parameters are graphed using JavaScript and the values are retrieved with PHP. The graphs update every 10 seconds and display the last 20 values. The webpage is accessed at the Pi’s IP address.

This feature allows various parameters to be measured and allows the easy identification of trends in these values. The function of this webpage is like the OLED display, in that it’s useful for the development of the system. This allowed for the identification of thermal throttling on the PI during testing.

*** Remote Motor/Servo Shutoff

   #+caption: Shutoff remote control.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/failsafe_remote_1.JPG]]

A remote shutoff system was implemented using Xbee radio modules and an IRF250 power MOSFET. The MOSFET cuts power to the motor speed controller and servo when the switch on the remote control unit is flipped. This system allows the car to be stopped remotely if it were to go out of control. The system is designed so that any failure will disconnect power to the motor and servo. If the Xbee on the car side loses signal or power, it will stop the motor.

** Unique Innovations
*** Custom Power Supply

   #+caption: Power Supply complete.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/powersupply.jpg]]

A custom power supply was designed to convert the 7.2v from the LiPo batteries to 5v for powering the car’s logic systems. The power supply is also capable of measuring battery power, voltage and current. The power supply is implemented using a LM2596-5.0 buck regulator IC, and an INA226 power monitoring IC. The power supply can supply the Raspberry Pi 4, which requires 5V at 3A as well as the ATMEGA328 board and other accessories. 

   #+caption: Power Supply schematic.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/powersupply_schematic.png]]

For the design of the power supply, a TI LM2596-5.0 “Simple Switcher” buck converter was chosen because of its efficiency, 3A output and ability to accept an input voltage as low as 7v. Originally a LM7805 based design with a bypass transistor was considered, but it would have been much less efficient. This would have reduced battery runtime and require a large heatsink which would have added weight. The values of L1, C1 and C2 were chosen based on the LM2596’s datasheet. The output current was assumed to be 3A, and the maximum input voltage as 12v (providing the ability to operate using a 3 cell LiPo if needed). 

The inductor L1 is a Bourns SRP1038A-220M which is shielded and has a saturation current of 5A. Since the components are in close proximity a shielded inductor is needed to prevent EMI from affecting the feedback line of the LM2596 (Pin 4) as well as the INA226 and I2C lines. The capacitors C1 and C2 are Nichicon aluminum polymer electrolytics, which have a very low (30 mΩ) ESR (equivalent series resistance). Low ESR is critical in a buck converter design because of the high current transients created by the switching. A low ESR allows the capacitor to charge and discharge faster to react to these transients. Diode D1 is a 50WQ04 Schottky diode which was used because of its fast switching time and low voltage drop.

For the power measurements, a TI INA226 current and power monitor was used because of its Linux driver support. The INA226 communicates with the Raspberry Pi over I2C, with R1 and R2 functioning as pull-up resistors. The INA226 measures current using a shunt resistor and measuring the voltage across it. The resistor’s value is programmed in at startup and from there an accurate current measurement can be taken. The shunt resistor Rshunt is a 0.002Ω 1% resistor as recommended in the INA226 datasheet.

   #+caption: Power Supply PCB layout.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/pcb_layout.png]]

Since the buck converter operates at a frequency of about 150kHz and used many surface mounted components, a custom PCB (printed circuit board) was designed using KiCad. The power supply was originally constructed on a protoboard (without the INA226 power measurement IC) and while it was somewhat functional it had stability issues and the output was limited to about 2A at 5V. The custom PCB eliminated all of these issues as well as creating a more mechanically robust design. 

High currents and frequencies are present in the power supply, so a ground plane design was used for the PCB. The back side of the board (shown in green) is copper filled and used as the ground connection for all components. Components on the front side of the board are connected to the ground plane using through-hole vias, which are holes drilled and electroplated through the board. The ground plane is also used as a heatsink for the LM2596 buck controller IC. Multiple vias were placed on the heatsink pad of the device to help conduct heat and serve as a ground connection. Thicker traces and shorter trace lengths are used for high current paths.

   #+caption: Power Supply PCB Before Assembly.
   #+attr_html: :width 300px
   #+attr_latex: :width \linewidth/2
   [[./figure/powersupply_pcb.jpg]]

The PCB’s were manufactured by OSHPark, and all components were hand soldered. The larger components such as the inductor, diode and buck regulator were hot air soldered and the smaller components were soldered using a fine soldering iron tip. Solder wick was used to remove excess solder and a few solder bridges between INA226 pins.

*** Reading Power Supply Data in Linux

To measure the battery voltage and power consumption, a TI INA226 power monitoring IC was added to the power supply design. Linux includes a driver to read data from this device, and in order to use it on the Raspberry PI configuration changes need to be made. Since the Raspberry Pi doesn’t support hardware autodetection on any interface except USB, a system known as device tree is used to describe the system’s hardware configuration. The device tree provides information on all the system’s hardware, such as the addresses, registers, driver parameters and other information. The device tree is read by the Linux kernel at boot and then loads the required drivers and their parameters.

#+BEGIN_SRC emacs-lisp
/dts-v1/;
/plugin/;
/ {
	fragment@0 {
		target = <&i2c1>;
		__overlay__ {
			status = "okay";
			ina226@40 {	
				compatible = "ti,ina226";
				reg = <0x40>;
				shunt-resistor = <2000>;
			};
		};
	};
};
#+END_SRC


To add support for the INA226 a device tree overlay needed to be created to insert it into the system’s device tree. The contents of this file are shown above. The bus that the INA226 is attached to is defined with ~target = <&i2c1>~, the driver is set with ~compatible = 'ti,ina226'~ and the address with ~reg = <0x40>~. The shunt resistor value is set with ~shunt-resistor = <2000>~, with the resistance value in micro-ohms. The shunt resistor value is the resistance of the current shunt connected to the INA226, which is used for current and power calculations. In this case the current shunt’s resistance is 0.02Ω. The device tree overlay is enabled in the Raspberry Pi’s ~/boot/config.txt~ file. 

Once the driver is set up the voltage, power and current measurements can be accessed by any Linux program. The ~sensors~ utility can be used to display these values.

** Problems
* Test Results
* Design Documentation (Appendix)
** System Hardware Schematic
[[./figure/full_schematic.png]]

** INA226 Device Tree Overlay (ina226.dts)
#+BEGIN_SRC emacs-lisp
/dts-v1/;
/plugin/;
/ {
	fragment@0 {
		target = <&i2c1>;
		__overlay__ {
			status = "okay";
			ina226@40 {	
				compatible = "ti,ina226";
				reg = <0x40>;
				shunt-resistor = <2000>;
			};
		};
	};
};
#+END_SRC

** Raspberry Pi Boot Configuration (/boot/config.txt)

#+BEGIN_SRC emacs-lisp
# See /boot/overlays/README for all available options

gpu_mem=64
initramfs initramfs-linux.img followkernel
dtparam=i2c1=on
dtparam=i2c_arm=on
disable_overscan=1
dtoverlay=ina226
hdmi_force_hotplug=1 
dtoverlay=gpio-shutdown,gpio_pin=5
#+END_SRC

