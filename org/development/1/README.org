#+LATEX_HEADER: \usepackage[letterpaper, margin = 1in]{geometry}
#+options: toc:t num:t
#+export_exclude_tags: noexport
#+latex_header: \usepackage{xcolor}
#+latex_header: \definecolor{code}{rgb}{0.95,0.95,0.95}

#+title: FrostAV Development
#+subtitle: Stage 1: Base
#+date: Updated \today

* System Abstraction
  #+attr_latex: :width 0.8\linewidth :placement [H]
  #+caption: Fundamental module abstraction. Consists of a wired-bus for inter-communication between modules on the Frost vehicle, and a wireless-bus for communication with a server or an ssh client. Bridge Controllers act as the coupling between the vehicle and the modules that do not depend on the vehicle interface. 
  [[../figure/2019-09-16_AbstractSystem.png]]

** Abstract System Operation Description
   The Frost Autonomous Vehicle consists of a vehicle and a system for
   controlling the vehicle. The vehicle provides an interface mainly
   to move it and to steer it. Bridge Controllers handle the
   peripherals that make up the vehicle interface. Bridge Controllers
   cannot operate unless they have instructions. These instructions
   come from a wired-bus. Different types of modules can send
   instructions to the wired-bus. The most important modules are the
   Networker and each individual Sensor System. Sensor Systems provide
   feedback for the Bridge Controllers to act upon. Furthermore, the
   Networker transfers information between the wired-bus and the
   wireless-bus. The wireless-bus allows for communication with
   devices that are not on the vehicle itself. Overall, the abstract
   system provides a map for how information is received and directed
   towards the vehicle's interaction with the environment. 

** Bridge Controllers
   "Bridge" refers to a software design pattern from the Gang of Four,
   which intends to "decouple an abstraction from its implementation
   so that the two can vary independently." As such, the Bridge
   Controllers will have software that implements the Bridge design
   pattern, so that implementation code (for a specific vehicle) is
   decoupled from the system interface.

** Networker
   The Networker is reponsible for transfering information between the
   wireless-bus and the wired-bus.

** Sensor Systems 
   Various Sensor Systems may be added to the wired-bus. An individual
   Sensor System should receive information from a sensor, process the
   information, and send the result to the wired-bus.
  
* System Plan
  #+attr_latex: :width 0.8\linewidth :placement [H]
  [[./figure/2019-09-22_Implementation.png]]

** System Operation Description
   The PS3 Eye Camera provides visual information about the
   environment. This information will be processed with the OpenCV
   library on a Raspberry Pi 2 with an Arch ARM operating
   system. Processed camera information will then be piped through
   \(I^2C\) to the Bridge Controllers. The Servo Bridge Controller has
   a PWM output which directly drives the steering servo. The Motor
   Bridge Controller has a PWM output that is handled by the
   electronic speed controller (ESC), which drives the motor.

** System Assumptions
  The assumption made in this development stage is that the motor
  speed and servo steering angle can be controlled individually, such
  that motor speed and steering angle do not require direct knowledge
  of each other. Hence, the arrows from the wired-bus to the Servo and
  Motor Bridge Controllers are unidirectional. This assumption is
  meant to simplify the \(I^2C\) wired-bus configuration - since
  bi-directional communication on this bus would require
  arbitration. 

** Bus Communication
   JSON will be used as the format for data for both the wireless and
   wired buses. JSON provides easy to understand data structure
   packets that can be serialized and sent as a stream. Using JSON
   sacrifices speed for readability and extendability of the system.

*** Wireless-Bus
   In this stage the wireless-bus should allow for an SSH
   client to connect to it. As such, JSON packets that would normally
   be sent to the wireless-bus, will instead be stored locally in
   the system, but will be callable from an SSH client. 

*** Wired-Bus
   For the wired-bus, \(I^2C\) will be used. \(I^2C\) addressing will
   be done manually for each slave connected to the bus. Data will be
   sent from master to slaves via the JSON format.

** Block Function Description
*** Raspberry Pi 2 (RPi2)
    The RPi2 has an Arch Linux ARM operating system. It is responsible
    for processing camera information from the PS3 Eye. It is also
    responsible for being the Networker, which transfers information
    between the wired and wireless buses.
*** Servo Bridge Controller (ATMEGA328P)
    Processes commands from the wired-bus to control the vehicle
    steering servo.
*** Motor Bridge Controller (ATMEGA328P)
    Processes commands from the wired-bus to control the vehicle
    motor's speed.
*** PS3 Eye Camera
    Provides images over USB, for environmental perception.
*** Electronic Speed Controller (DYNS2211)
    Takes in a PWM signal and outputs an amplified and directional PWM
    wave to the vehicle's motor.


* Control Abstraction
  #+attr_latex: :width \linewidth :placement [H]
  [[../figure/2019-10-24_controlLoop.png]]

* Control Plan
  #+attr_latex: :width \linewidth :placement [H]
  [[../figure/2019-10-24_cameraToControl.png]]


* Future
** I2C Arbitration
   It is expected that modules communicating on the wired bus will
   need to communicate with each-other. In this case, there would be
   multiple masters on a single i2c bus. To implement this,
   arbitration would be necessary so that masters on the bus do not
   interrupt each other.
    
    
** COMMENT Resources
   - http://www.mbeddedc.com/2017/09/i2c-bus-arbitration.html
   - https://www.geeksforgeeks.org/bus-arbitration-in-computer-organization/

* Steering PID
** Concept
   :PROPERTIES:
   :CUSTOM_ID: sec:steeringPid_concept
   :END:
   #+name: fig:pidBlockDiagram
   #+caption: A block diagram of a PID controller in a feedback loop. r(t) is the desired process value or setpoint (SP), and y(t) is the measured process value (PV). \footnotesize /Arturo Urquizo, CC BY-SA 3.0 https://creativecommons.org/licenses/by-sa/3.0/
   #+attr_latex: :width 0.6\linewidth :placement [H]
   [[./figure/2019-11-05_pidBlockDiagram.png]]

   A PID controller can be used to correct the steering of an
   autonomous vehicle. Given a vehicle with the task of following a
   line or path, the vehicle must be able to detect the path as well
   as where it is in relation to the path. The difference can be
   taken from these two pieces of information to form the cross-track
   error. The cross-track error will be sent as the input to the PID
   --- in figure [[fig:pidBlockDiagram]], the cross-track error is denoted
   \(e(t)\). 

   The PID has three control terms that are summed together to get a
   control variable output. Proportional control allows the vehicle to
   steer harder when it is further from the path. Derivative control
   induces a resistance to the pull from the proportional control;
   this brings the car smoothly back to the path in a timely manner
   while reducing the chance that the vehicle will overshoot the path
   due to the proportional control. Finally, the integral control
   corrects for external effects such as wind and terrain. 

   Each of these controls rely on a properly tuned PID. To tune a PID,
   each control term has a gain which must be adjusted until the
   system is stable. Such details will not be covered in this
   document.
   
** Parts
   #+name: table:pidParts
   #+attr_latex: :placement [H]
   +----------------+-------------------------------------------+
   | Part           | Purpose                                   |
   +----------------+-------------------------------------------+
   |Arduino Uno (AVR|Steering Vehicle Interface Controller that |
   |  attmega328p)  | interfaces between the Pi and the vehicle |
   |                |                  servo.                   |
   +----------------+-------------------------------------------+
   |Standard Hobby  |The same type of servo that will be to     |
   |Servo           |steer the vehicle.                         |
   +----------------+-------------------------------------------+

** Experimental Setup
   #+name: fig:pidExperimentalSetup
   #+caption: The Arduino provides microsecond PWM values from 800 to 2200\(\mu s\) to the servo. The servo reacts to an error value via a software PID controller. Since there is nothing in this setup that generates a true error value, error values must either be simulated or retrieved from a feedback sensor (such as a camera). The values along the circumference are microsecond values that correspond to the servo position; they help verify the accuracy of the PID.
   #+attr_latex: :width 0.5\linewidth :placement [H]
   [[./figure/2019-11-05_pidExperimentalSetup.JPG]]

** Software Design
   All code in this section was compiled using the avr-g++ tool, and
   using C++17. Test code was compiled with g++ as opposed to avr-g++.

*** USART to Command the Servo from a Terminal Emulator
    In order to talk to the servo, we need to set up the USART on the
    AVR microcontroller.
*** Servo Control 
    To control the position of the servo, the attmega328p has a 16-bit
    timer. Once we set up the timer, we can provide it a pulse
    duration between the accepted values of the servo (typically
    1-2\(\si{ms}\)).

    The code for the servo is at the register level. Ideally, one
    should use a hardware abstraction layer (HAL) to avoid writing
    production code at a register level. In our =main.cpp= file, we
    have the following to set up our servo.

    #+BEGIN_SRC C++
#include <avr/io.h>

static constexpr uint32_t hertzToCycles(uint16_t hertz) {
    return clockFrequency/prescaler/hertz;
}

static void setupServoPwm() {
	DDRB |= 1 << PINB1; //Set pin 9 on arduino to output

	TCCR1A |=
        1 << WGM11 | //PWM Mode 14 (1/3)
        1 << COM1A0 | //Inverting Mode (1/2)
        1 << COM1A1; //Inverting Mode (2/2)
    
	TCCR1B |=
        1 << WGM12 | //PWM Mode 14 (2/3)
        1 << WGM13 | //PWM Mode 14 (3/3)
        1 << CS11; //Prescaler: 8

    //50Hz PWM to cycles for servo
	ICR1 = hertzToCycles(pwmFrequency)-1;
}
    #+END_SRC

    Information regarding the registers is in the attmega328p
    datasheet. Importantly, the servo uses the MCU's 16-bit
    Timer/Counter1 with PWM.
*** Clamping
    One common problem is providing a servo with a PWM value outside
    the valid range of the servo. For example, our servo has a maximum
    acceptable pulse width of 2200\(\mu s\). If we provide our servo
    with a pulse width 2300\(\mu s\), it could damage the servo. We
    will discuss a simple method for clamping the pulse widths
    provided to the servo. 

    The =Clamp= class looks as follows:
    
    #+attr_latex: :options bgcolor=code
    #+BEGIN_SRC C++
#ifndef CLAMP_HPP
#define CLAMP_HPP

#include <stdint.h>

struct Bounds {
    int16_t lower;
    int16_t upper;
};

class Clamp {
    Bounds bounds;

public:
    constexpr static Clamp makeFromBounds(Bounds bounds) {
        return Clamp(bounds);
    }

    constexpr Clamp(Bounds bounds): bounds{bounds} {}

    int16_t clamp(int16_t value) {
        return (value < bounds.lower) ? bounds.lower :
            (value > bounds.upper) ? bounds.upper:
            value;
    }

    Clamp() {}
};

#endif    
    #+END_SRC

    The class takes in a =Bounds= and uses the =clamp= member function
    to output a value between the upper and lower bounds. Since we are
    using this code on a microcontroller, we want an object of type
    =Clamp= to be initialized at compile-time. To do this we declare
    the constructor, and the static factory method, as =constexpr=. To
    ensure compile-time initialization, we must pass a constant
    expression or rvalue to either the static factory method or the
    constructor. 
    
    Here is a unit test suite, using CxxTest, for the =Clamp= class:
    #+attr_latex: :options bgcolor=code
    #+BEGIN_SRC C++
#include <cxxtest/TestSuite.h>
#include "Clamp.hpp"

class TestClamp: public CxxTest::TestSuite {
    Clamp clamp;
    Bounds bounds;
    
public:
    void setUp() {
        bounds = {
            .lower = 10,
            .upper = 20
        };
        
        clamp = Clamp::makeFromBounds(bounds);
    }
    
    void test_inputAboveUpper_clampsToUpper() {
        int16_t expected = bounds.upper;
        int16_t actual = clamp.clamp(25);
        TS_ASSERT_EQUALS(actual, expected);
    }

    void test_inputBelowLower_clampsToLower() {
        int16_t expected = bounds.lower;
        int16_t actual = clamp.clamp(5);
        TS_ASSERT_EQUALS(actual, expected);
    }

    void test_inputBetweenBounds_noClamp() {
        int16_t expected = 15;
        int16_t actual = clamp.clamp(15);
        TS_ASSERT_EQUALS(actual, expected);
    }
};
    #+END_SRC

    Each =test_= function in the test suite demonstrates the
    functionality of the =Clamp= class. It also includes the way we
    recommend instantiating the =Clamp= class. That is, by using the
    static factory method as opposed to the constructor.
    #+attr_latex: :options bgcolor=code
    #+BEGIN_SRC C++
clamp = Clamp::makeFromBounds({
        .lower = 10,
        .upper = 20 });
    #+END_SRC

    This is purely for readability, so the reader can understand
    that a =Clamp= object requires a =Bounds=.

    Again, after instantiating the =Clamp= class, you can use it as,
    #+BEGIN_SRC C++
int16_t clampedValue = clamp.clamp(5); // Returns 10 since the lower bound is 10.
    #+END_SRC
 
*** PID
    As discussed in section [[#sec:steeringPid_concept]], a PID will
    provide reactive control to the servo from error feedback. In our
    system, the camera detects lanes. The further the car is from
    being centered between those lanes, the greater the error that is
    input into our steering PID. We've encapsulated the algorithm for
    a PID in a class.

    #+BEGIN_SRC C++
#ifndef PID_HPP
#define PID_HPP

#include <stdint.h>

struct Pid {
    struct Component {
        int16_t proportional;
        int16_t integral;
        int16_t derivative;
    };

private:    
    Component gain;
    Component error;
    int16_t scale;
    
public:
    int16_t updateError(int16_t error);
    
    constexpr static Pid makeFromGain(Component gain) {
        return Pid(gain);
    }
    
    constexpr explicit Pid(Component gain):
        gain{gain}, error{}, scale{1} {}

    
    constexpr static Pid makeFromScaledGain(int16_t scale, Component gain) {
        return Pid(scale, gain);
    }
    
    constexpr Pid(int16_t scale, Component gain):
        gain{gain}, error{}, scale{scale} {}

    Pid() {}
};

#endif
    #+END_SRC

    The PID takes in a structure of gains (proportional, integral, and
    derivative). Then, when =updateError= is called, it will return
    the control variable output of the PID. 

    Since we may have gains that are decimal values, and assuming we
    don't want to do floating point arithmetic on a microcontroller,
    we've included a scale variable which divides the final output of
    the PID. This means if we provide a gain value of =1= (for one of
    the control gains) and a scale of =10=, then we equivalently have
    a gain value of =1/10=. To get this behavior, we use the
    =makeFromScaleGain= to instantiate the =Pid= class, instead of
    =makeFromGain=.

    The definition of the =updateError= function is
    #+BEGIN_SRC C++
int16_t Pid::updateError(int16_t newError) {
    error.integral += newError;
    error.derivative = newError - error.proportional;
    error.proportional = newError;

    return (gain.proportional*error.proportional +
            gain.integral*error.integral +
            gain.derivative*error.derivative) / scale ;    
}
    #+END_SRC

    Notice the result is divided by scale, as discussed
    above. Furthermore, we've provided a unit test that demonstrates
    how to use this class.

    #+BEGIN_SRC C++
#include <cxxtest/TestSuite.h>
#include "Pid.hpp"

class TestPid: public CxxTest::TestSuite {
public:
    void test_errorInput_returnsCorrectedOutput() {
        Pid pid = Pid::makeFromGain({
                .proportional = 1,
                .integral = 2,
                .derivative = 3 });
        
        int16_t actual = pid.updateError(2);
        int16_t expected = 12;

        TS_ASSERT_EQUALS(actual, expected);
    }

    void test_scaledGain() {
        int16_t scale = 100;
        
        Pid pid = Pid::makeFromScaledGain(scale, {
                .proportional = 100,
                .integral = 200,
                .derivative = 300 });
        
        int16_t actual = pid.updateError(2);
        int16_t expected = 12;

        TS_ASSERT_EQUALS(actual, expected);
    }
};    
    #+END_SRC

    Ideally, the user would call =updateError= iteratively
*** Makefile to Facilitate Building, Running, and Testing
    A makefile keeps builds up to date. It can also be as a general
    purpose script for shell commands, as we will see.
